import c from "../utils/getOppositePlacement.mjs";
import u from "../utils/getBasePlacement.mjs";
import R from "../utils/getOppositeVariationPlacement.mjs";
import Z from "../utils/detectOverflow.mjs";
import S from "../utils/computeAutoPlacement.mjs";
import { auto as C, start as ee, right as ae, left as te, bottom as _, top as q } from "../enums.mjs";
import re from "../utils/getVariation.mjs";
function oe(t) {
  if (u(t) === C)
    return [];
  var e = c(t);
  return [R(t), e, R(e)];
}
function ne(t) {
  var e = t.state, a = t.options, b = t.name;
  if (!e.modifiersData[b]._skip) {
    for (var g = a.mainAxis, I = g === void 0 ? !0 : g, k = a.altAxis, V = k === void 0 ? !0 : k, j = a.fallbackPlacements, y = a.padding, A = a.boundary, h = a.rootBoundary, z = a.altBoundary, x = a.flipVariations, d = x === void 0 ? !0 : x, G = a.allowedAutoPlacements, r = e.options.placement, H = u(r), J = H === r, K = j || (J || !d ? [c(r)] : oe(r)), i = [r].concat(K).reduce(function(l, n) {
      return l.concat(u(n) === C ? S(e, {
        placement: n,
        boundary: A,
        rootBoundary: h,
        padding: y,
        flipVariations: d,
        allowedAutoPlacements: G
      }) : n);
    }, []), L = e.rects.reference, N = e.rects.popper, B = /* @__PURE__ */ new Map(), w = !0, s = i[0], m = 0; m < i.length; m++) {
      var o = i[m], F = u(o), O = re(o) === ee, $ = [q, _].indexOf(F) >= 0, M = $ ? "width" : "height", v = Z(e, {
        placement: o,
        boundary: A,
        rootBoundary: h,
        altBoundary: z,
        padding: y
      }), f = $ ? O ? ae : te : O ? _ : q;
      L[M] > N[M] && (f = c(f));
      var Q = c(f), p = [];
      if (I && p.push(v[F] <= 0), V && p.push(v[f] <= 0, v[Q] <= 0), p.every(function(l) {
        return l;
      })) {
        s = o, w = !1;
        break;
      }
      B.set(o, p);
    }
    if (w)
      for (var T = d ? 3 : 1, U = function(n) {
        var D = i.find(function(X) {
          var E = B.get(X);
          if (E)
            return E.slice(0, n).every(function(Y) {
              return Y;
            });
        });
        if (D)
          return s = D, "break";
      }, P = T; P > 0; P--) {
        var W = U(P);
        if (W === "break")
          break;
      }
    e.placement !== s && (e.modifiersData[b]._skip = !0, e.placement = s, e.reset = !0);
  }
}
const de = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: ne,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
export {
  de as default
};
//# sourceMappingURL=flip.mjs.map
