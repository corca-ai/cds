import R from "./dom-utils/getCompositeRect.mjs";
import w from "./dom-utils/getLayoutRect.mjs";
import b from "./dom-utils/listScrollParents.mjs";
import B from "./dom-utils/getOffsetParent.mjs";
import L from "./utils/orderModifiers.mjs";
import N from "./utils/debounce.mjs";
import S from "./utils/mergeByName.mjs";
import { isElement as T } from "./dom-utils/instanceOf.mjs";
var U = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function F() {
  for (var a = arguments.length, c = new Array(a), n = 0; n < a; n++)
    c[n] = arguments[n];
  return !c.some(function(m) {
    return !(m && typeof m.getBoundingClientRect == "function");
  });
}
function J(a) {
  a === void 0 && (a = {});
  var c = a, n = c.defaultModifiers, m = n === void 0 ? [] : n, M = c.defaultOptions, v = M === void 0 ? U : M;
  return function(p, g, u) {
    u === void 0 && (u = v);
    var e = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, U, v),
      modifiersData: {},
      elements: {
        reference: p,
        popper: g
      },
      attributes: {},
      styles: {}
    }, y = [], E = !1, i = {
      state: e,
      setOptions: function(r) {
        var f = typeof r == "function" ? r(e.options) : r;
        h(), e.options = Object.assign({}, v, e.options, f), e.scrollParents = {
          reference: T(p) ? b(p) : p.contextElement ? b(p.contextElement) : [],
          popper: b(g)
        };
        var s = L(S([].concat(m, e.options.modifiers)));
        return e.orderedModifiers = s.filter(function(o) {
          return o.enabled;
        }), D(), i.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!E) {
          var r = e.elements, f = r.reference, s = r.popper;
          if (F(f, s)) {
            e.rects = {
              reference: R(f, B(s), e.options.strategy === "fixed"),
              popper: w(s)
            }, e.reset = !1, e.placement = e.options.placement, e.orderedModifiers.forEach(function(P) {
              return e.modifiersData[P.name] = Object.assign({}, P.data);
            });
            for (var o = 0; o < e.orderedModifiers.length; o++) {
              if (e.reset === !0) {
                e.reset = !1, o = -1;
                continue;
              }
              var d = e.orderedModifiers[o], l = d.fn, O = d.options, j = O === void 0 ? {} : O, C = d.name;
              typeof l == "function" && (e = l({
                state: e,
                options: j,
                name: C,
                instance: i
              }) || e);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: N(function() {
        return new Promise(function(t) {
          i.forceUpdate(), t(e);
        });
      }),
      destroy: function() {
        h(), E = !0;
      }
    };
    if (!F(p, g))
      return i;
    i.setOptions(u).then(function(t) {
      !E && u.onFirstUpdate && u.onFirstUpdate(t);
    });
    function D() {
      e.orderedModifiers.forEach(function(t) {
        var r = t.name, f = t.options, s = f === void 0 ? {} : f, o = t.effect;
        if (typeof o == "function") {
          var d = o({
            state: e,
            name: r,
            instance: i,
            options: s
          }), l = function() {
          };
          y.push(d || l);
        }
      });
    }
    function h() {
      y.forEach(function(t) {
        return t();
      }), y = [];
    }
    return i;
  };
}
export {
  J as popperGenerator
};
//# sourceMappingURL=createPopper.mjs.map
