import { start as M, top as B, left as w, bottom as S, right as _ } from "../enums.mjs";
import Aa from "../utils/getBasePlacement.mjs";
import fa from "../utils/getMainAxisFromPlacement.mjs";
import ya from "../utils/getAltAxis.mjs";
import { within as D, withinMaxClamp as ga } from "../utils/within.mjs";
import ba from "../dom-utils/getLayoutRect.mjs";
import Oa from "../dom-utils/getOffsetParent.mjs";
import Ba from "../utils/detectOverflow.mjs";
import wa from "../utils/getVariation.mjs";
import Da from "../utils/getFreshSideObject.mjs";
import { max as Ra, min as ja } from "../utils/math.mjs";
function ka(A) {
  var a = A.state, e = A.options, aa = A.name, R = e.mainAxis, ra = R === void 0 ? !0 : R, j = e.altAxis, ta = j === void 0 ? !1 : j, ea = e.boundary, ia = e.rootBoundary, oa = e.altBoundary, va = e.padding, k = e.tether, i = k === void 0 ? !0 : k, F = e.tetherOffset, f = F === void 0 ? 0 : F, c = Ba(a, {
    boundary: ea,
    rootBoundary: ia,
    padding: va,
    altBoundary: oa
  }), T = Aa(a.placement), y = wa(a.placement), q = !y, r = fa(T), n = ya(r), p = a.modifiersData.popperOffsets, o = a.rects.reference, l = a.rects.popper, u = typeof f == "function" ? f(Object.assign({}, a.rects, {
    placement: a.placement
  })) : f, m = typeof u == "number" ? {
    mainAxis: u,
    altAxis: u
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, u), x = a.modifiersData.offset ? a.modifiersData.offset[a.placement] : null, g = {
    x: 0,
    y: 0
  };
  if (p) {
    if (ra) {
      var z, C = r === "y" ? B : w, I = r === "y" ? S : _, t = r === "y" ? "height" : "width", s = p[r], V = s + c[C], $ = s - c[I], E = i ? -l[t] / 2 : 0, ma = y === M ? o[t] : l[t], sa = y === M ? -l[t] : -o[t], G = a.elements.arrow, na = i && G ? ba(G) : {
        width: 0,
        height: 0
      }, H = a.modifiersData["arrow#persistent"] ? a.modifiersData["arrow#persistent"].padding : Da(), J = H[C], K = H[I], d = D(0, o[t], na[t]), pa = q ? o[t] / 2 - E - d - J - m.mainAxis : ma - d - J - m.mainAxis, la = q ? -o[t] / 2 + E + d + K + m.mainAxis : sa + d + K + m.mainAxis, b = a.elements.arrow && Oa(a.elements.arrow), ca = b ? r === "y" ? b.clientTop || 0 : b.clientLeft || 0 : 0, N = (z = x == null ? void 0 : x[r]) != null ? z : 0, ua = s + pa - N - ca, xa = s + la - N, P = D(i ? ja(V, ua) : V, s, i ? Ra($, xa) : $);
      p[r] = P, g[r] = P - s;
    }
    if (ta) {
      var Q, da = r === "x" ? B : w, ha = r === "x" ? S : _, v = p[n], h = n === "y" ? "height" : "width", U = v + c[da], W = v - c[ha], O = [B, w].indexOf(T) !== -1, X = (Q = x == null ? void 0 : x[n]) != null ? Q : 0, Y = O ? U : v - o[h] - l[h] - X + m.altAxis, Z = O ? v + o[h] + l[h] - X - m.altAxis : W, L = i && O ? ga(Y, v, Z) : D(i ? Y : U, v, i ? Z : W);
      p[n] = L, g[n] = L - v;
    }
    a.modifiersData[aa] = g;
  }
}
const Ja = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: ka,
  requiresIfExists: ["offset"]
};
export {
  Ja as default
};
//# sourceMappingURL=preventOverflow.mjs.map
