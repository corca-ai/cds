{"version":3,"file":"preventOverflow.mjs","sources":["../../../../../../../../../node_modules/.pnpm/@popperjs+core@2.11.8/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js"],"sourcesContent":["import { top, left, right, bottom, start } from \"../enums.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getMainAxisFromPlacement from \"../utils/getMainAxisFromPlacement.js\";\nimport getAltAxis from \"../utils/getAltAxis.js\";\nimport { within, withinMaxClamp } from \"../utils/within.js\";\nimport getLayoutRect from \"../dom-utils/getLayoutRect.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\nimport getVariation from \"../utils/getVariation.js\";\nimport getFreshSideObject from \"../utils/getFreshSideObject.js\";\nimport { min as mathMin, max as mathMax } from \"../utils/math.js\";\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = offset + overflow[mainSide];\n    var max = offset - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? mathMin(min, tetherMin) : min, offset, tether ? mathMax(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n\n    var _mainSide = mainAxis === 'x' ? top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _len = altAxis === 'y' ? 'height' : 'width';\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};"],"names":["preventOverflow","_ref","state","options","name","_options$mainAxis","checkMainAxis","_options$altAxis","checkAltAxis","boundary","rootBoundary","altBoundary","padding","_options$tether","tether","_options$tetherOffset","tetherOffset","overflow","detectOverflow","basePlacement","getBasePlacement","variation","getVariation","isBasePlacement","mainAxis","getMainAxisFromPlacement","altAxis","getAltAxis","popperOffsets","referenceRect","popperRect","tetherOffsetValue","normalizedTetherOffsetValue","offsetModifierState","data","_offsetModifierState$","mainSide","top","left","altSide","bottom","right","len","offset","min","max","additive","minLen","start","maxLen","arrowElement","arrowRect","getLayoutRect","arrowPaddingObject","getFreshSideObject","arrowPaddingMin","arrowPaddingMax","arrowLen","within","minOffset","maxOffset","arrowOffsetParent","getOffsetParent","clientOffset","offsetModifierValue","tetherMin","tetherMax","preventedOffset","mathMin","mathMax","_offsetModifierState$2","_mainSide","_altSide","_offset","_len","_min","_max","isOriginSide","_offsetModifierValue","_tetherMin","_tetherMax","_preventedOffset","withinMaxClamp","preventOverflow$1"],"mappings":"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","x_google_ignoreList":[0]}