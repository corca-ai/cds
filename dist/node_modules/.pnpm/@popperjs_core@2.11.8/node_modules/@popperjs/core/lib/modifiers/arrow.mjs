import q from "../utils/getBasePlacement.mjs";
import E from "../dom-utils/getLayoutRect.mjs";
import R from "../dom-utils/contains.mjs";
import H from "../dom-utils/getOffsetParent.mjs";
import M from "../utils/getMainAxisFromPlacement.mjs";
import { within as S } from "../utils/within.mjs";
import T from "../utils/mergePaddingObject.mjs";
import z from "../utils/expandToHashMap.mjs";
import { basePlacements as A, top as B, left as O, bottom as F, right as P } from "../enums.mjs";
var I = function(e, r) {
  return e = typeof e == "function" ? e(Object.assign({}, r.rects, {
    placement: r.placement
  })) : e, T(typeof e != "number" ? e : z(e, A));
};
function L(o) {
  var e, r = o.state, n = o.name, t = o.options, f = r.elements.arrow, s = r.modifiersData.popperOffsets, p = q(r.placement), a = M(p), b = [O, P].indexOf(p) >= 0, i = b ? "height" : "width";
  if (!(!f || !s)) {
    var c = I(t.padding, r), v = E(f), d = a === "y" ? B : O, g = a === "y" ? F : P, h = r.rects.reference[i] + r.rects.reference[a] - s[a] - r.rects.popper[i], x = s[a] - r.rects.reference[a], m = H(f), l = m ? a === "y" ? m.clientHeight || 0 : m.clientWidth || 0 : 0, y = h / 2 - x / 2, j = c[d], D = l - v[i] - c[g], u = l / 2 - v[i] / 2 + y, w = S(j, u, D), $ = a;
    r.modifiersData[n] = (e = {}, e[$] = w, e.centerOffset = w - u, e);
  }
}
function V(o) {
  var e = o.state, r = o.options, n = r.element, t = n === void 0 ? "[data-popper-arrow]" : n;
  t != null && (typeof t == "string" && (t = e.elements.popper.querySelector(t), !t) || R(e.elements.popper, t) && (e.elements.arrow = t));
}
const X = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: L,
  effect: V,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
export {
  X as default
};
//# sourceMappingURL=arrow.mjs.map
