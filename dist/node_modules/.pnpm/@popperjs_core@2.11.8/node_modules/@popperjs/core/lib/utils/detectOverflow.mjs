import M from "../dom-utils/getClippingRect.mjs";
import q from "../dom-utils/getDocumentElement.mjs";
import z from "../dom-utils/getBoundingClientRect.mjs";
import A from "./computeOffsets.mjs";
import F from "./rectToClientRect.mjs";
import { basePlacements as G, popper as o, clippingParents as I, reference as J, right as K, bottom as _, top as L, viewport as N } from "../enums.mjs";
import { isElement as Q } from "../dom-utils/instanceOf.mjs";
import S from "./mergePaddingObject.mjs";
import U from "./expandToHashMap.mjs";
function re(e, a) {
  a === void 0 && (a = {});
  var t = a, c = t.placement, s = c === void 0 ? e.placement : c, v = t.strategy, h = v === void 0 ? e.strategy : v, g = t.boundary, B = g === void 0 ? I : g, u = t.rootBoundary, $ = u === void 0 ? N : u, y = t.elementContext, r = y === void 0 ? o : y, b = t.altBoundary, j = b === void 0 ? !1 : b, C = t.padding, m = C === void 0 ? 0 : C, n = S(typeof m != "number" ? m : U(m, G)), E = r === o ? J : o, x = e.rects.popper, l = e.elements[j ? E : r], p = M(Q(l) ? l : l.contextElement || q(e.elements.popper), B, $, h), O = z(e.elements.reference), w = A({
    reference: O,
    element: x,
    strategy: "absolute",
    placement: s
  }), D = F(Object.assign({}, x, w)), i = r === o ? D : O, f = {
    top: p.top - i.top + n.top,
    bottom: i.bottom - p.bottom + n.bottom,
    left: p.left - i.left + n.left,
    right: i.right - p.right + n.right
  }, R = e.modifiersData.offset;
  if (r === o && R) {
    var P = R[s];
    Object.keys(f).forEach(function(d) {
      var T = [K, _].indexOf(d) >= 0 ? 1 : -1, H = [L, _].indexOf(d) >= 0 ? "y" : "x";
      f[d] += P[H] * T;
    });
  }
  return f;
}
export {
  re as default
};
//# sourceMappingURL=detectOverflow.mjs.map
