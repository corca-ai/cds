{"version":3,"file":"createPopper.mjs","sources":["../../../../../../../../node_modules/.pnpm/@popperjs+core@2.11.8/node_modules/@popperjs/core/lib/createPopper.js"],"sourcesContent":["import getCompositeRect from \"./dom-utils/getCompositeRect.js\";\nimport getLayoutRect from \"./dom-utils/getLayoutRect.js\";\nimport listScrollParents from \"./dom-utils/listScrollParents.js\";\nimport getOffsetParent from \"./dom-utils/getOffsetParent.js\";\nimport orderModifiers from \"./utils/orderModifiers.js\";\nimport debounce from \"./utils/debounce.js\";\nimport mergeByName from \"./utils/mergeByName.js\";\nimport detectOverflow from \"./utils/detectOverflow.js\";\nimport { isElement } from \"./dom-utils/instanceOf.js\";\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nexport function popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        });\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref) {\n        var name = _ref.name,\n            _ref$options = _ref.options,\n            options = _ref$options === void 0 ? {} : _ref$options,\n            effect = _ref.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nexport var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\nexport { detectOverflow };"],"names":["DEFAULT_OPTIONS","areValidElements","_len","args","_key","element","popperGenerator","generatorOptions","_generatorOptions","_generatorOptions$def","defaultModifiers","_generatorOptions$def2","defaultOptions","reference","popper","options","state","effectCleanupFns","isDestroyed","instance","setOptionsAction","cleanupModifierEffects","isElement","listScrollParents","orderedModifiers","orderModifiers","mergeByName","m","runModifierEffects","_state$elements","getCompositeRect","getOffsetParent","getLayoutRect","modifier","index","_state$orderedModifie","fn","_state$orderedModifie2","_options","name","debounce","resolve","_ref","_ref$options","effect","cleanupFn","noopFn"],"mappings":"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","x_google_ignoreList":[0]}