import * as t from "react";
import { ManagerReferenceNodeContext as U } from "./Manager.mjs";
import { setRef as g, unwrapArray as D } from "./utils.mjs";
import { usePopper as $ } from "./usePopper.mjs";
var F = function() {
}, I = function() {
  return Promise.resolve(null);
}, b = [];
function C(e) {
  var p = e.placement, o = p === void 0 ? "bottom" : p, d = e.strategy, l = d === void 0 ? "absolute" : d, m = e.modifiers, u = m === void 0 ? b : m, y = e.referenceElement, c = e.onFirstUpdate, f = e.innerRef, M = e.children, S = t.useContext(U), P = t.useState(null), a = P[0], v = P[1], E = t.useState(null), s = E[0], O = E[1];
  t.useEffect(function() {
    g(f, a);
  }, [f, a]);
  var w = t.useMemo(function() {
    return {
      placement: o,
      strategy: l,
      onFirstUpdate: c,
      modifiers: [].concat(u, [{
        name: "arrow",
        enabled: s != null,
        options: {
          element: s
        }
      }])
    };
  }, [o, l, c, u, s]), n = $(y || S, a, w), r = n.state, i = n.styles, R = n.forceUpdate, h = n.update, N = t.useMemo(function() {
    return {
      ref: v,
      style: i.popper,
      placement: r ? r.placement : o,
      hasPopperEscaped: r && r.modifiersData.hide ? r.modifiersData.hide.hasPopperEscaped : null,
      isReferenceHidden: r && r.modifiersData.hide ? r.modifiersData.hide.isReferenceHidden : null,
      arrowProps: {
        style: i.arrow,
        ref: O
      },
      forceUpdate: R || F,
      update: h || I
    };
  }, [v, O, o, r, i, h, R]);
  return D(M)(N);
}
export {
  C as Popper
};
//# sourceMappingURL=Popper.mjs.map
